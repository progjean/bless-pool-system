import React, { useState } from 'react';
import { Customer } from '../../types/customer';
import { Invoice } from '../../types/invoice';
import { useLanguage } from '../../context/LanguageContext';
import { calculateNextGenerationDate, generateRecurringInvoices } from '../../utils/invoiceGenerator';
import { RecurringInvoiceEditModal } from '../invoices/RecurringInvoiceEditModal';
import { formatCurrency } from '../../utils/formatUtils';
import './CustomerRecurringInvoices.css';

interface CustomerRecurringInvoicesProps {
  customer: Customer;
  invoices: Invoice[];
  onUpdateCustomer?: (updates: Partial<Customer>) => void;
  onGenerateInvoices?: (newInvoices: Invoice[]) => void;
}

export const CustomerRecurringInvoices: React.FC<CustomerRecurringInvoicesProps> = ({
  customer,
  invoices,
  onUpdateCustomer,
  onGenerateInvoices,
}) => {
  const { t, language } = useLanguage();
  const [isEditing, setIsEditing] = useState(false);
  const [isGenerating, setIsGenerating] = useState(false);

  const customerInvoices = invoices.filter(inv => inv.customerId === customer.id && inv.isRecurring);
  
  const getLastGeneratedDate = (): string | null => {
    if (customerInvoices.length === 0) return null;
    const sorted = customerInvoices.sort((a, b) => 
      new Date(b.issueDate).getTime() - new Date(a.issueDate).getTime()
    );
    return sorted[0].issueDate;
  };

  const getNextGenerationDate = (): Date => {
    const lastGenerated = customer.lastInvoiceGeneratedDate || getLastGeneratedDate();
    if (lastGenerated) {
      return calculateNextGenerationDate(customer, new Date(lastGenerated));
    }
    return calculateNextGenerationDate(customer);
  };

  const handleGenerate = () => {
    if (!onGenerateInvoices) return;
    setIsGenerating(true);
    try {
      const newInvoices = generateRecurringInvoices([customer], invoices);
      if (newInvoices.length > 0) {
        onGenerateInvoices(newInvoices);
        alert(`${newInvoices.length} ${t('invoice.generatedCount').replace('{count}', String(newInvoices.length))}`);
      } else {
        alert(t('invoice.noCustomersToGenerate'));
      }
    } catch (error) {
      console.error('Error generating invoices:', error);
      alert(language === 'pt-BR' ? 'Erro ao gerar invoices' : 'Error generating invoices');
    } finally {
      setIsGenerating(false);
    }
  };

  const handleSaveEdit = (updates: Partial<Customer>) => {
    if (onUpdateCustomer) {
      onUpdateCustomer(updates);
      setIsEditing(false);
    }
  };

  const isAutoGenerateEnabled = customer.autoGenerateInvoices !== false;
  const lastGenerated = getLastGeneratedDate();
  const nextGeneration = getNextGenerationDate();

  // Verificar se cliente é elegível para invoices recorrentes
  if (!customer.frequency || !customer.chargePerMonth || customer.chargePerMonth <= 0) {
    return (
      <div className="customer-recurring-invoices">
        <div className="empty-state">
          <p>{language === 'pt-BR' 
            ? 'Cliente não configurado para invoices recorrentes. Configure frequência e valor mensal no cadastro.'
            : 'Customer not configured for recurring invoices. Configure frequency and monthly charge in the registration.'}
          </p>
        </div>
      </div>
    );
  }

  return (
    <div className="customer-recurring-invoices">
      <div className="section-header">
        <h2>{t('invoice.recurringTemplates')}</h2>
        <div className="header-actions">
          <button 
            onClick={handleGenerate} 
            className="generate-button"
            disabled={isGenerating}
          >
            {isGenerating ? (language === 'pt-BR' ? 'Gerando...' : 'Generating...') : t('invoice.generateNow')}
          </button>
          <button 
            onClick={() => setIsEditing(true)} 
            className="edit-button"
          >
            ✏️ {t('common.edit')}
          </button>
        </div>
      </div>

      <div className="recurring-info-card">
        <div className="info-header">
          <div className="info-badges">
            <span className={`badge frequency ${customer.frequency.toLowerCase()}`}>
              {customer.frequency === 'Weekly' ? (language === 'pt-BR' ? 'Semanal' : 'Weekly') : (language === 'pt-BR' ? 'Quinzenal' : 'Biweekly')}
            </span>
            <span className={`badge auto-generate ${isAutoGenerateEnabled ? 'enabled' : 'disabled'}`}>
              {isAutoGenerateEnabled ? t('invoice.autoGenerateEnabled') : t('invoice.autoGenerateDisabled')}
            </span>
          </div>
        </div>

        <div className="info-grid">
          <div className="info-item">
            <span className="info-label">{t('customerForm.chargePerMonth')}:</span>
            <span className="info-value">
              {formatCurrency(customer.chargePerMonth, language)}
            </span>
          </div>

          <div className="info-item">
            <span className="info-label">{t('customerForm.serviceDay')}:</span>
            <span className="info-value">
              {customer.serviceDay === 'Monday' ? (language === 'pt-BR' ? 'Segunda' : 'Monday') :
               customer.serviceDay === 'Tuesday' ? (language === 'pt-BR' ? 'Terça' : 'Tuesday') :
               customer.serviceDay === 'Wednesday' ? (language === 'pt-BR' ? 'Quarta' : 'Wednesday') :
               customer.serviceDay === 'Thursday' ? (language === 'pt-BR' ? 'Quinta' : 'Thursday') :
               customer.serviceDay === 'Friday' ? (language === 'pt-BR' ? 'Sexta' : 'Friday') :
               customer.serviceDay === 'Saturday' ? (language === 'pt-BR' ? 'Sábado' : 'Saturday') :
               (language === 'pt-BR' ? 'Domingo' : 'Sunday')}
            </span>
          </div>

          {lastGenerated && (
            <div className="info-item">
              <span className="info-label">{t('invoice.lastGenerated')}:</span>
              <span className="info-value">
                {new Date(lastGenerated).toLocaleDateString(language === 'pt-BR' ? 'pt-BR' : 'en-US')}
              </span>
            </div>
          )}

          <div className="info-item">
            <span className="info-label">{t('invoice.nextGeneration')}:</span>
            <span className="info-value highlight">
              {nextGeneration.toLocaleDateString(language === 'pt-BR' ? 'pt-BR' : 'en-US')}
            </span>
          </div>

          <div className="info-item">
            <span className="info-label">{language === 'pt-BR' ? 'Invoices Geradas' : 'Generated Invoices'}:</span>
            <span className="info-value">
              {customerInvoices.length}
            </span>
          </div>

          <div className="info-item">
            <span className="info-label">{t('customerForm.startOn')}:</span>
            <span className="info-value">
              {new Date(customer.startOn).toLocaleDateString(language === 'pt-BR' ? 'pt-BR' : 'en-US')}
            </span>
          </div>

          <div className="info-item">
            <span className="info-label">{t('customerForm.stopAfter')}:</span>
            <span className="info-value">
              {customer.stopAfter === 'NO END' ? t('customerForm.stopAfter.noEnd') : new Date(customer.stopAfter).toLocaleDateString(language === 'pt-BR' ? 'pt-BR' : 'en-US')}
            </span>
          </div>
        </div>
      </div>

      {isEditing && (
        <RecurringInvoiceEditModal
          customer={customer}
          onClose={() => setIsEditing(false)}
          onSave={handleSaveEdit}
        />
      )}
    </div>
  );
};

