// Servi√ßo para gerenciar Invoices usando Supabase
import { supabase, isSupabaseConfigured, handleSupabaseError, isTableNotFoundError } from './supabase';
import { Invoice, InvoiceItem } from '../types/invoice';
import { showToast } from '../utils/toast';
import { dataCache, createCacheKey, cachedAsync } from '../utils/cache';

// Converter Invoice para formato Supabase
const invoiceToSupabase = (invoice: Invoice) => ({
  invoice_number: invoice.invoiceNumber,
  customer_id: invoice.customerId,
  customer_name: invoice.customerName,
  issue_date: invoice.issueDate,
  due_date: invoice.dueDate,
  paid_date: invoice.paidDate || null,
  status: invoice.status,
  subtotal: invoice.subtotal,
  late_fee: invoice.lateFee || null,
  late_fee_applied: invoice.lateFeeApplied || false,
  late_fee_applied_date: invoice.lateFeeAppliedDate || null,
  total: invoice.total,
  notes: invoice.notes || null,
  is_recurring: invoice.isRecurring,
  email_sent: invoice.emailSent || false,
  email_sent_date: invoice.emailSentDate || null,
  auto_generated: invoice.autoGenerated || false,
  generated_from_customer_id: invoice.generatedFromCustomerId || null,
  company_id: null, // Ser√° preenchido pelo RLS
});

// Converter do formato Supabase para Invoice
const supabaseToInvoice = (row: any, items: any[] = []): Invoice => ({
  id: row.id,
  invoiceNumber: row.invoice_number,
  customerId: row.customer_id,
  customerName: row.customer_name,
  issueDate: row.issue_date,
  dueDate: row.due_date,
  paidDate: row.paid_date || undefined,
  status: row.status,
  subtotal: parseFloat(row.subtotal),
  lateFee: row.late_fee ? parseFloat(row.late_fee) : undefined,
  lateFeeApplied: row.late_fee_applied || false,
  lateFeeAppliedDate: row.late_fee_applied_date || undefined,
  total: parseFloat(row.total),
  items: items.map(item => ({
    id: item.id,
    description: item.description,
    quantity: parseFloat(item.quantity),
    unitPrice: parseFloat(item.unit_price),
    total: parseFloat(item.total),
  })),
  notes: row.notes || undefined,
  isRecurring: row.is_recurring,
  emailSent: row.email_sent || false,
  emailSentDate: row.email_sent_date || undefined,
  autoGenerated: row.auto_generated || false,
  generatedFromCustomerId: row.generated_from_customer_id || undefined,
  createdAt: row.created_at,
  updatedAt: row.updated_at,
});

export const invoicesService = {
  // Listar todas as invoices
  async list(): Promise<Invoice[]> {
    const cacheKey = createCacheKey('invoices', 'list');
    
    return cachedAsync(cacheKey, async () => {
      if (!isSupabaseConfigured()) {
        const saved = localStorage.getItem('invoices');
        return saved ? JSON.parse(saved) : [];
      }

      try {
        const { data, error } = await supabase
          .from('invoices')
          .select('*')
          .order('created_at', { ascending: false });

        if (error) throw error;

        // Buscar items para cada invoice
        const invoices = await Promise.all(
          (data || []).map(async (invoice) => {
            const { data: items } = await supabase
              .from('invoice_items')
              .select('*')
              .eq('invoice_id', invoice.id);
            
            return supabaseToInvoice(invoice, items || []);
          })
        );

        return invoices;
      } catch (error: any) {
        // Se a tabela n√£o existe, usar fallback para localStorage
        if (isTableNotFoundError(error)) {
          console.warn('‚ö†Ô∏è Tabela invoices n√£o encontrada no Supabase. Usando fallback para localStorage.');
          console.warn('üìã Para resolver: Execute o arquivo supabase/schema.sql no SQL Editor do Supabase Dashboard.');
          const saved = localStorage.getItem('invoices');
          return saved ? JSON.parse(saved) : [];
        }
        const errorMessage = handleSupabaseError(error);
        showToast.error(`Erro ao carregar invoices: ${errorMessage}`);
        throw error;
      }
    }, 5 * 60 * 1000); // Cache por 5 minutos
  },

  // Buscar invoice por ID
  async get(id: string): Promise<Invoice | null> {
    if (!isSupabaseConfigured()) {
      const saved = localStorage.getItem('invoices');
      const invoices = saved ? JSON.parse(saved) : [];
      return invoices.find((i: Invoice) => i.id === id) || null;
    }

    try {
      const { data: invoice, error: invoiceError } = await supabase
        .from('invoices')
        .select('*')
        .eq('id', id)
        .single();

      if (invoiceError) throw invoiceError;
      if (!invoice) return null;

      const { data: items } = await supabase
        .from('invoice_items')
        .select('*')
        .eq('invoice_id', id);

      return supabaseToInvoice(invoice, items || []);
    } catch (error) {
      const errorMessage = handleSupabaseError(error);
      showToast.error(`Erro ao carregar invoice: ${errorMessage}`);
      throw error;
    }
  },

  // Criar nova invoice
  async create(invoice: Invoice): Promise<Invoice> {
    if (!isSupabaseConfigured()) {
      const saved = localStorage.getItem('invoices');
      const invoices = saved ? JSON.parse(saved) : [];
      const newInvoice = { ...invoice, id: `inv_${Date.now()}` };
      invoices.push(newInvoice);
      localStorage.setItem('invoices', JSON.stringify(invoices));
      return newInvoice;
    }

    try {
      const supabaseData = invoiceToSupabase(invoice);
      
      // Criar invoice
      const { data: invoiceData, error: invoiceError } = await supabase
        .from('invoices')
        .insert(supabaseData as any)
        .select()
        .single();

      if (invoiceError) throw invoiceError;
      if (!invoiceData) throw new Error('Invoice data is null');

      // Criar items
      if (invoice.items && invoice.items.length > 0) {
        const itemsData = invoice.items.map(item => ({
          invoice_id: (invoiceData as any).id,
          description: item.description,
          quantity: item.quantity,
          unit_price: item.unitPrice,
          total: item.total,
        }));

        const { error: itemsError } = await supabase
          .from('invoice_items')
          .insert(itemsData as any);

        if (itemsError) throw itemsError;
      }

      // Invalidar cache
      dataCache.invalidatePattern('^invoices:');
      
      showToast.success('Invoice criada com sucesso!');
      
      // Buscar invoice completa com items
      return await this.get((invoiceData as any).id);
    } catch (error) {
      const errorMessage = handleSupabaseError(error);
      showToast.error(`Erro ao criar invoice: ${errorMessage}`);
      throw error;
    }
  },

  // Atualizar invoice
  async update(id: string, invoice: Invoice): Promise<Invoice> {
    if (!isSupabaseConfigured()) {
      const saved = localStorage.getItem('invoices');
      const invoices = saved ? JSON.parse(saved) : [];
      const index = invoices.findIndex((i: Invoice) => i.id === id);
      if (index !== -1) {
        invoices[index] = { ...invoice, id, updatedAt: new Date().toISOString() };
        localStorage.setItem('invoices', JSON.stringify(invoices));
        return invoices[index];
      }
      throw new Error('Invoice n√£o encontrada');
    }

    try {
      const supabaseData = invoiceToSupabase(invoice);
      
      // Atualizar invoice
      const { error: invoiceError } = await supabase
        .from('invoices')
        .update(supabaseData as any)
        .eq('id', id);

      if (invoiceError) throw invoiceError;

      // Deletar items antigos e criar novos
      await supabase
        .from('invoice_items')
        .delete()
        .eq('invoice_id', id);

      if (invoice.items && invoice.items.length > 0) {
        const itemsData = invoice.items.map(item => ({
          invoice_id: id,
          description: item.description,
          quantity: item.quantity,
          unit_price: item.unitPrice,
          total: item.total,
        }));

        const { error: itemsError } = await supabase
          .from('invoice_items')
          .insert(itemsData as any);

        if (itemsError) throw itemsError;
      }

      // Invalidar cache
      dataCache.invalidatePattern('^invoices:');
      dataCache.invalidate(createCacheKey('invoices', id));

      showToast.success('Invoice atualizada com sucesso!');
      return await this.get(id);
    } catch (error) {
      const errorMessage = handleSupabaseError(error);
      showToast.error(`Erro ao atualizar invoice: ${errorMessage}`);
      throw error;
    }
  },

  // Deletar invoice
  async delete(id: string): Promise<void> {
    if (!isSupabaseConfigured()) {
      const saved = localStorage.getItem('invoices');
      const invoices = saved ? JSON.parse(saved) : [];
      const filtered = invoices.filter((i: Invoice) => i.id !== id);
      localStorage.setItem('invoices', JSON.stringify(filtered));
      return;
    }

    try {
      // Deletar items primeiro (cascade j√° faz isso, mas √© bom ser expl√≠cito)
      await supabase
        .from('invoice_items')
        .delete()
        .eq('invoice_id', id);

      const { error } = await supabase
        .from('invoices')
        .delete()
        .eq('id', id);

      if (error) throw error;

      // Invalidar cache
      dataCache.invalidatePattern('^invoices:');
      dataCache.invalidate(createCacheKey('invoices', id));

      showToast.success('Invoice deletada com sucesso!');
    } catch (error) {
      const errorMessage = handleSupabaseError(error);
      showToast.error(`Erro ao deletar invoice: ${errorMessage}`);
      throw error;
    }
  },
};

